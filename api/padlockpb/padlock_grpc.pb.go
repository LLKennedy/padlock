// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package padlockpb

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ExposedPadlockClient is the client API for ExposedPadlock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExposedPadlockClient interface {
	// PostHello initiates a session with the application, generating an authentication token
	PostHello(ctx context.Context, in *AuthHello, opts ...grpc.CallOption) (*AuthToken, error)
	// GetApplicationListModules lists modules already connected to the application
	GetApplicationListModules(ctx context.Context, in *ApplicationListModulesRequest, opts ...grpc.CallOption) (*ApplicationListModulesResponse, error)
	// GetApplicationConnect connects a new module to the application
	GetApplicationConnect(ctx context.Context, in *ApplicationConnectRequest, opts ...grpc.CallOption) (ExposedPadlock_GetApplicationConnectClient, error)
	// GetModuleListSlots lists the slots on a module
	GetModuleListSlots(ctx context.Context, in *ModuleListSlotsRequest, opts ...grpc.CallOption) (*ModuleListSlotsResponse, error)
	// GetModuleInfo gets info for a specific module
	GetModuleInfo(ctx context.Context, in *ModuleInfoRequest, opts ...grpc.CallOption) (*ModuleInfoResponse, error)
	// GetSlotListMechanisms lists the mechanisms available on a slot
	GetSlotListMechanisms(ctx context.Context, in *SlotListMechanismsRequest, opts ...grpc.CallOption) (*SlotListMechanismsResponse, error)
	// PostSlotInitToken creates the token in the slot
	PostSlotInitToken(ctx context.Context, in *SlotInitTokenRequest, opts ...grpc.CallOption) (*SlotInitTokenResponse, error)
	// GetSlotOpenSession creates a session on the slot
	GetSlotOpenSession(ctx context.Context, in *SlotOpenSessionRequest, opts ...grpc.CallOption) (ExposedPadlock_GetSlotOpenSessionClient, error)
	// PostSessionKeepalive keeps a session alive without taking any action agains the HSM itself
	PostSessionKeepAlive(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*empty.Empty, error)
	// DeleteSessionClose closes the session
	DeleteSessionClose(ctx context.Context, in *SessionCloseRequest, opts ...grpc.CallOption) (*SessionCloseResponse, error)
	// PutSessionLogin logs into the session at the application level
	PutSessionLogin(ctx context.Context, in *SessionLoginRequest, opts ...grpc.CallOption) (*SessionLoginResponse, error)
	// PutSessionLogout logs out of the session at the application level
	PutSessionLogout(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*SessionLogoutResponse, error)
	// GetSessionListObjects lists the objects available in the session
	GetSessionListObjects(ctx context.Context, in *SessionListObjectsRequest, opts ...grpc.CallOption) (ExposedPadlock_GetSessionListObjectsClient, error)
	// PostSessionCreateObject creates an object
	PostSessionCreateObject(ctx context.Context, in *SessionCreateObjectRequest, opts ...grpc.CallOption) (*P11Object, error)
	// PostSessionGenerateRandom generates random data, exercising the CSPRNG
	PostSessionGenerateRandom(ctx context.Context, in *SessionGenerateRandomRequest, opts ...grpc.CallOption) (*SessionGenerateRandomResponse, error)
	// PostSessionGenerateKeyPair generates a keypair
	PostSessionGenerateKeyPair(ctx context.Context, in *SessionGenerateKeyPairRequest, opts ...grpc.CallOption) (*SessionGenerateKeyPairResponse, error)
	// PostSessionGenerateKey generates a key
	PostSessionGenerateKey(ctx context.Context, in *SessionGenerateKeyRequest, opts ...grpc.CallOption) (*P11Object, error)
	// GetObjectListAttributeValues lists values for the requested attributes
	GetObjectListAttributeValues(ctx context.Context, in *ObjectListAttributeValuesRequest, opts ...grpc.CallOption) (ExposedPadlock_GetObjectListAttributeValuesClient, error)
	// PostEncrypt encrypts data
	PostEncrypt(ctx context.Context, in *ObjectEncryptRequest, opts ...grpc.CallOption) (*ObjectEncryptResponse, error)
	// GetEncryptSegmented encrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	GetEncryptSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetEncryptSegmentedClient, error)
	// PostDecrypt decrypts data
	PostDecrypt(ctx context.Context, in *ObjectDecryptRequest, opts ...grpc.CallOption) (*ObjectDecryptResponse, error)
	// GetDecryptSegmented decrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	GetDecryptSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetDecryptSegmentedClient, error)
	// PostSign signs a message
	PostSign(ctx context.Context, in *ObjectSignRequest, opts ...grpc.CallOption) (*ObjectSignResponse, error)
	// GetSignSegmented signs multiple data segments individually then one final part, for those few mechanisms where it matters
	GetSignSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetSignSegmentedClient, error)
	// PostVerify verifies a message and signature
	PostVerify(ctx context.Context, in *ObjectVerifyRequest, opts ...grpc.CallOption) (*ObjectVerifyResponse, error)
	// GetVerifySegmented verifies multiple data segments individually then the final signature, for those  few mechanisms where it matters.
	GetVerifySegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetVerifySegmentedClient, error)
	// PutWrapKey wraps a key
	PutWrapKey(ctx context.Context, in *ObjectWrapKeyRequest, opts ...grpc.CallOption) (*ObjectWrapKeyResponse, error)
	// PutUnwrapKey unwraps a key
	PutUnwrapKey(ctx context.Context, in *ObjectUnwrapKeyRequest, opts ...grpc.CallOption) (*P11Object, error)
	// DeleteDestroyObject destroys an object
	DeleteDestroyObject(ctx context.Context, in *ObjectDestroyObjectRequest, opts ...grpc.CallOption) (*ObjectDestroyObjectResponse, error)
	// PutCopyObject copies an object with new attributes if possible
	PutCopyObject(ctx context.Context, in *ObjectCopyObjectRequest, opts ...grpc.CallOption) (*P11Object, error)
}

type exposedPadlockClient struct {
	cc grpc.ClientConnInterface
}

func NewExposedPadlockClient(cc grpc.ClientConnInterface) ExposedPadlockClient {
	return &exposedPadlockClient{cc}
}

func (c *exposedPadlockClient) PostHello(ctx context.Context, in *AuthHello, opts ...grpc.CallOption) (*AuthToken, error) {
	out := new(AuthToken)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetApplicationListModules(ctx context.Context, in *ApplicationListModulesRequest, opts ...grpc.CallOption) (*ApplicationListModulesResponse, error) {
	out := new(ApplicationListModulesResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/GetApplicationListModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetApplicationConnect(ctx context.Context, in *ApplicationConnectRequest, opts ...grpc.CallOption) (ExposedPadlock_GetApplicationConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[0], "/padlock.ExposedPadlock/GetApplicationConnect", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetApplicationConnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExposedPadlock_GetApplicationConnectClient interface {
	Recv() (*ApplicationConnectUpdate, error)
	grpc.ClientStream
}

type exposedPadlockGetApplicationConnectClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetApplicationConnectClient) Recv() (*ApplicationConnectUpdate, error) {
	m := new(ApplicationConnectUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) GetModuleListSlots(ctx context.Context, in *ModuleListSlotsRequest, opts ...grpc.CallOption) (*ModuleListSlotsResponse, error) {
	out := new(ModuleListSlotsResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/GetModuleListSlots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetModuleInfo(ctx context.Context, in *ModuleInfoRequest, opts ...grpc.CallOption) (*ModuleInfoResponse, error) {
	out := new(ModuleInfoResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/GetModuleInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetSlotListMechanisms(ctx context.Context, in *SlotListMechanismsRequest, opts ...grpc.CallOption) (*SlotListMechanismsResponse, error) {
	out := new(SlotListMechanismsResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/GetSlotListMechanisms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PostSlotInitToken(ctx context.Context, in *SlotInitTokenRequest, opts ...grpc.CallOption) (*SlotInitTokenResponse, error) {
	out := new(SlotInitTokenResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSlotInitToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetSlotOpenSession(ctx context.Context, in *SlotOpenSessionRequest, opts ...grpc.CallOption) (ExposedPadlock_GetSlotOpenSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[1], "/padlock.ExposedPadlock/GetSlotOpenSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetSlotOpenSessionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExposedPadlock_GetSlotOpenSessionClient interface {
	Recv() (*SlotOpenSessionUpdate, error)
	grpc.ClientStream
}

type exposedPadlockGetSlotOpenSessionClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetSlotOpenSessionClient) Recv() (*SlotOpenSessionUpdate, error) {
	m := new(SlotOpenSessionUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostSessionKeepAlive(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSessionKeepAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) DeleteSessionClose(ctx context.Context, in *SessionCloseRequest, opts ...grpc.CallOption) (*SessionCloseResponse, error) {
	out := new(SessionCloseResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/DeleteSessionClose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PutSessionLogin(ctx context.Context, in *SessionLoginRequest, opts ...grpc.CallOption) (*SessionLoginResponse, error) {
	out := new(SessionLoginResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PutSessionLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PutSessionLogout(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*SessionLogoutResponse, error) {
	out := new(SessionLogoutResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PutSessionLogout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetSessionListObjects(ctx context.Context, in *SessionListObjectsRequest, opts ...grpc.CallOption) (ExposedPadlock_GetSessionListObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[2], "/padlock.ExposedPadlock/GetSessionListObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetSessionListObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExposedPadlock_GetSessionListObjectsClient interface {
	Recv() (*P11Object, error)
	grpc.ClientStream
}

type exposedPadlockGetSessionListObjectsClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetSessionListObjectsClient) Recv() (*P11Object, error) {
	m := new(P11Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostSessionCreateObject(ctx context.Context, in *SessionCreateObjectRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSessionCreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PostSessionGenerateRandom(ctx context.Context, in *SessionGenerateRandomRequest, opts ...grpc.CallOption) (*SessionGenerateRandomResponse, error) {
	out := new(SessionGenerateRandomResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSessionGenerateRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PostSessionGenerateKeyPair(ctx context.Context, in *SessionGenerateKeyPairRequest, opts ...grpc.CallOption) (*SessionGenerateKeyPairResponse, error) {
	out := new(SessionGenerateKeyPairResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSessionGenerateKeyPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PostSessionGenerateKey(ctx context.Context, in *SessionGenerateKeyRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSessionGenerateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetObjectListAttributeValues(ctx context.Context, in *ObjectListAttributeValuesRequest, opts ...grpc.CallOption) (ExposedPadlock_GetObjectListAttributeValuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[3], "/padlock.ExposedPadlock/GetObjectListAttributeValues", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetObjectListAttributeValuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ExposedPadlock_GetObjectListAttributeValuesClient interface {
	Recv() (*ObjectListAttributeValuesUpdate, error)
	grpc.ClientStream
}

type exposedPadlockGetObjectListAttributeValuesClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetObjectListAttributeValuesClient) Recv() (*ObjectListAttributeValuesUpdate, error) {
	m := new(ObjectListAttributeValuesUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostEncrypt(ctx context.Context, in *ObjectEncryptRequest, opts ...grpc.CallOption) (*ObjectEncryptResponse, error) {
	out := new(ObjectEncryptResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostEncrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetEncryptSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetEncryptSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[4], "/padlock.ExposedPadlock/GetEncryptSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetEncryptSegmentedClient{stream}
	return x, nil
}

type ExposedPadlock_GetEncryptSegmentedClient interface {
	Send(*ObjectEncryptSegmentedRequest) error
	Recv() (*ObjectEncryptSegmentedResponse, error)
	grpc.ClientStream
}

type exposedPadlockGetEncryptSegmentedClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetEncryptSegmentedClient) Send(m *ObjectEncryptSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exposedPadlockGetEncryptSegmentedClient) Recv() (*ObjectEncryptSegmentedResponse, error) {
	m := new(ObjectEncryptSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostDecrypt(ctx context.Context, in *ObjectDecryptRequest, opts ...grpc.CallOption) (*ObjectDecryptResponse, error) {
	out := new(ObjectDecryptResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostDecrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetDecryptSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetDecryptSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[5], "/padlock.ExposedPadlock/GetDecryptSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetDecryptSegmentedClient{stream}
	return x, nil
}

type ExposedPadlock_GetDecryptSegmentedClient interface {
	Send(*ObjectDecryptSegmentedRequest) error
	Recv() (*ObjectDecryptSegmentedResponse, error)
	grpc.ClientStream
}

type exposedPadlockGetDecryptSegmentedClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetDecryptSegmentedClient) Send(m *ObjectDecryptSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exposedPadlockGetDecryptSegmentedClient) Recv() (*ObjectDecryptSegmentedResponse, error) {
	m := new(ObjectDecryptSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostSign(ctx context.Context, in *ObjectSignRequest, opts ...grpc.CallOption) (*ObjectSignResponse, error) {
	out := new(ObjectSignResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetSignSegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetSignSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[6], "/padlock.ExposedPadlock/GetSignSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetSignSegmentedClient{stream}
	return x, nil
}

type ExposedPadlock_GetSignSegmentedClient interface {
	Send(*ObjectSignSegmentedRequest) error
	CloseAndRecv() (*ObjectSignSegmentedResponse, error)
	grpc.ClientStream
}

type exposedPadlockGetSignSegmentedClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetSignSegmentedClient) Send(m *ObjectSignSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exposedPadlockGetSignSegmentedClient) CloseAndRecv() (*ObjectSignSegmentedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectSignSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PostVerify(ctx context.Context, in *ObjectVerifyRequest, opts ...grpc.CallOption) (*ObjectVerifyResponse, error) {
	out := new(ObjectVerifyResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PostVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) GetVerifySegmented(ctx context.Context, opts ...grpc.CallOption) (ExposedPadlock_GetVerifySegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExposedPadlock_serviceDesc.Streams[7], "/padlock.ExposedPadlock/GetVerifySegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &exposedPadlockGetVerifySegmentedClient{stream}
	return x, nil
}

type ExposedPadlock_GetVerifySegmentedClient interface {
	Send(*ObjectVerifySegmentedRequest) error
	CloseAndRecv() (*ObjectVerifySegmentedResponse, error)
	grpc.ClientStream
}

type exposedPadlockGetVerifySegmentedClient struct {
	grpc.ClientStream
}

func (x *exposedPadlockGetVerifySegmentedClient) Send(m *ObjectVerifySegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *exposedPadlockGetVerifySegmentedClient) CloseAndRecv() (*ObjectVerifySegmentedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectVerifySegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *exposedPadlockClient) PutWrapKey(ctx context.Context, in *ObjectWrapKeyRequest, opts ...grpc.CallOption) (*ObjectWrapKeyResponse, error) {
	out := new(ObjectWrapKeyResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PutWrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PutUnwrapKey(ctx context.Context, in *ObjectUnwrapKeyRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PutUnwrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) DeleteDestroyObject(ctx context.Context, in *ObjectDestroyObjectRequest, opts ...grpc.CallOption) (*ObjectDestroyObjectResponse, error) {
	out := new(ObjectDestroyObjectResponse)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/DeleteDestroyObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exposedPadlockClient) PutCopyObject(ctx context.Context, in *ObjectCopyObjectRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.ExposedPadlock/PutCopyObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExposedPadlockServer is the server API for ExposedPadlock service.
// All implementations must embed UnimplementedExposedPadlockServer
// for forward compatibility
type ExposedPadlockServer interface {
	// PostHello initiates a session with the application, generating an authentication token
	PostHello(context.Context, *AuthHello) (*AuthToken, error)
	// GetApplicationListModules lists modules already connected to the application
	GetApplicationListModules(context.Context, *ApplicationListModulesRequest) (*ApplicationListModulesResponse, error)
	// GetApplicationConnect connects a new module to the application
	GetApplicationConnect(*ApplicationConnectRequest, ExposedPadlock_GetApplicationConnectServer) error
	// GetModuleListSlots lists the slots on a module
	GetModuleListSlots(context.Context, *ModuleListSlotsRequest) (*ModuleListSlotsResponse, error)
	// GetModuleInfo gets info for a specific module
	GetModuleInfo(context.Context, *ModuleInfoRequest) (*ModuleInfoResponse, error)
	// GetSlotListMechanisms lists the mechanisms available on a slot
	GetSlotListMechanisms(context.Context, *SlotListMechanismsRequest) (*SlotListMechanismsResponse, error)
	// PostSlotInitToken creates the token in the slot
	PostSlotInitToken(context.Context, *SlotInitTokenRequest) (*SlotInitTokenResponse, error)
	// GetSlotOpenSession creates a session on the slot
	GetSlotOpenSession(*SlotOpenSessionRequest, ExposedPadlock_GetSlotOpenSessionServer) error
	// PostSessionKeepalive keeps a session alive without taking any action agains the HSM itself
	PostSessionKeepAlive(context.Context, *SessionID) (*empty.Empty, error)
	// DeleteSessionClose closes the session
	DeleteSessionClose(context.Context, *SessionCloseRequest) (*SessionCloseResponse, error)
	// PutSessionLogin logs into the session at the application level
	PutSessionLogin(context.Context, *SessionLoginRequest) (*SessionLoginResponse, error)
	// PutSessionLogout logs out of the session at the application level
	PutSessionLogout(context.Context, *SessionID) (*SessionLogoutResponse, error)
	// GetSessionListObjects lists the objects available in the session
	GetSessionListObjects(*SessionListObjectsRequest, ExposedPadlock_GetSessionListObjectsServer) error
	// PostSessionCreateObject creates an object
	PostSessionCreateObject(context.Context, *SessionCreateObjectRequest) (*P11Object, error)
	// PostSessionGenerateRandom generates random data, exercising the CSPRNG
	PostSessionGenerateRandom(context.Context, *SessionGenerateRandomRequest) (*SessionGenerateRandomResponse, error)
	// PostSessionGenerateKeyPair generates a keypair
	PostSessionGenerateKeyPair(context.Context, *SessionGenerateKeyPairRequest) (*SessionGenerateKeyPairResponse, error)
	// PostSessionGenerateKey generates a key
	PostSessionGenerateKey(context.Context, *SessionGenerateKeyRequest) (*P11Object, error)
	// GetObjectListAttributeValues lists values for the requested attributes
	GetObjectListAttributeValues(*ObjectListAttributeValuesRequest, ExposedPadlock_GetObjectListAttributeValuesServer) error
	// PostEncrypt encrypts data
	PostEncrypt(context.Context, *ObjectEncryptRequest) (*ObjectEncryptResponse, error)
	// GetEncryptSegmented encrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	GetEncryptSegmented(ExposedPadlock_GetEncryptSegmentedServer) error
	// PostDecrypt decrypts data
	PostDecrypt(context.Context, *ObjectDecryptRequest) (*ObjectDecryptResponse, error)
	// GetDecryptSegmented decrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	GetDecryptSegmented(ExposedPadlock_GetDecryptSegmentedServer) error
	// PostSign signs a message
	PostSign(context.Context, *ObjectSignRequest) (*ObjectSignResponse, error)
	// GetSignSegmented signs multiple data segments individually then one final part, for those few mechanisms where it matters
	GetSignSegmented(ExposedPadlock_GetSignSegmentedServer) error
	// PostVerify verifies a message and signature
	PostVerify(context.Context, *ObjectVerifyRequest) (*ObjectVerifyResponse, error)
	// GetVerifySegmented verifies multiple data segments individually then the final signature, for those  few mechanisms where it matters.
	GetVerifySegmented(ExposedPadlock_GetVerifySegmentedServer) error
	// PutWrapKey wraps a key
	PutWrapKey(context.Context, *ObjectWrapKeyRequest) (*ObjectWrapKeyResponse, error)
	// PutUnwrapKey unwraps a key
	PutUnwrapKey(context.Context, *ObjectUnwrapKeyRequest) (*P11Object, error)
	// DeleteDestroyObject destroys an object
	DeleteDestroyObject(context.Context, *ObjectDestroyObjectRequest) (*ObjectDestroyObjectResponse, error)
	// PutCopyObject copies an object with new attributes if possible
	PutCopyObject(context.Context, *ObjectCopyObjectRequest) (*P11Object, error)
	mustEmbedUnimplementedExposedPadlockServer()
}

// UnimplementedExposedPadlockServer must be embedded to have forward compatible implementations.
type UnimplementedExposedPadlockServer struct {
}

func (UnimplementedExposedPadlockServer) PostHello(context.Context, *AuthHello) (*AuthToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostHello not implemented")
}
func (UnimplementedExposedPadlockServer) GetApplicationListModules(context.Context, *ApplicationListModulesRequest) (*ApplicationListModulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApplicationListModules not implemented")
}
func (UnimplementedExposedPadlockServer) GetApplicationConnect(*ApplicationConnectRequest, ExposedPadlock_GetApplicationConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetApplicationConnect not implemented")
}
func (UnimplementedExposedPadlockServer) GetModuleListSlots(context.Context, *ModuleListSlotsRequest) (*ModuleListSlotsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleListSlots not implemented")
}
func (UnimplementedExposedPadlockServer) GetModuleInfo(context.Context, *ModuleInfoRequest) (*ModuleInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModuleInfo not implemented")
}
func (UnimplementedExposedPadlockServer) GetSlotListMechanisms(context.Context, *SlotListMechanismsRequest) (*SlotListMechanismsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlotListMechanisms not implemented")
}
func (UnimplementedExposedPadlockServer) PostSlotInitToken(context.Context, *SlotInitTokenRequest) (*SlotInitTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSlotInitToken not implemented")
}
func (UnimplementedExposedPadlockServer) GetSlotOpenSession(*SlotOpenSessionRequest, ExposedPadlock_GetSlotOpenSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSlotOpenSession not implemented")
}
func (UnimplementedExposedPadlockServer) PostSessionKeepAlive(context.Context, *SessionID) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSessionKeepAlive not implemented")
}
func (UnimplementedExposedPadlockServer) DeleteSessionClose(context.Context, *SessionCloseRequest) (*SessionCloseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSessionClose not implemented")
}
func (UnimplementedExposedPadlockServer) PutSessionLogin(context.Context, *SessionLoginRequest) (*SessionLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSessionLogin not implemented")
}
func (UnimplementedExposedPadlockServer) PutSessionLogout(context.Context, *SessionID) (*SessionLogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSessionLogout not implemented")
}
func (UnimplementedExposedPadlockServer) GetSessionListObjects(*SessionListObjectsRequest, ExposedPadlock_GetSessionListObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSessionListObjects not implemented")
}
func (UnimplementedExposedPadlockServer) PostSessionCreateObject(context.Context, *SessionCreateObjectRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSessionCreateObject not implemented")
}
func (UnimplementedExposedPadlockServer) PostSessionGenerateRandom(context.Context, *SessionGenerateRandomRequest) (*SessionGenerateRandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSessionGenerateRandom not implemented")
}
func (UnimplementedExposedPadlockServer) PostSessionGenerateKeyPair(context.Context, *SessionGenerateKeyPairRequest) (*SessionGenerateKeyPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSessionGenerateKeyPair not implemented")
}
func (UnimplementedExposedPadlockServer) PostSessionGenerateKey(context.Context, *SessionGenerateKeyRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSessionGenerateKey not implemented")
}
func (UnimplementedExposedPadlockServer) GetObjectListAttributeValues(*ObjectListAttributeValuesRequest, ExposedPadlock_GetObjectListAttributeValuesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetObjectListAttributeValues not implemented")
}
func (UnimplementedExposedPadlockServer) PostEncrypt(context.Context, *ObjectEncryptRequest) (*ObjectEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostEncrypt not implemented")
}
func (UnimplementedExposedPadlockServer) GetEncryptSegmented(ExposedPadlock_GetEncryptSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEncryptSegmented not implemented")
}
func (UnimplementedExposedPadlockServer) PostDecrypt(context.Context, *ObjectDecryptRequest) (*ObjectDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostDecrypt not implemented")
}
func (UnimplementedExposedPadlockServer) GetDecryptSegmented(ExposedPadlock_GetDecryptSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDecryptSegmented not implemented")
}
func (UnimplementedExposedPadlockServer) PostSign(context.Context, *ObjectSignRequest) (*ObjectSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSign not implemented")
}
func (UnimplementedExposedPadlockServer) GetSignSegmented(ExposedPadlock_GetSignSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetSignSegmented not implemented")
}
func (UnimplementedExposedPadlockServer) PostVerify(context.Context, *ObjectVerifyRequest) (*ObjectVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostVerify not implemented")
}
func (UnimplementedExposedPadlockServer) GetVerifySegmented(ExposedPadlock_GetVerifySegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method GetVerifySegmented not implemented")
}
func (UnimplementedExposedPadlockServer) PutWrapKey(context.Context, *ObjectWrapKeyRequest) (*ObjectWrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutWrapKey not implemented")
}
func (UnimplementedExposedPadlockServer) PutUnwrapKey(context.Context, *ObjectUnwrapKeyRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutUnwrapKey not implemented")
}
func (UnimplementedExposedPadlockServer) DeleteDestroyObject(context.Context, *ObjectDestroyObjectRequest) (*ObjectDestroyObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDestroyObject not implemented")
}
func (UnimplementedExposedPadlockServer) PutCopyObject(context.Context, *ObjectCopyObjectRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutCopyObject not implemented")
}
func (UnimplementedExposedPadlockServer) mustEmbedUnimplementedExposedPadlockServer() {}

// UnsafeExposedPadlockServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExposedPadlockServer will
// result in compilation errors.
type UnsafeExposedPadlockServer interface {
	mustEmbedUnimplementedExposedPadlockServer()
}

func RegisterExposedPadlockServer(s *grpc.Server, srv ExposedPadlockServer) {
	s.RegisterService(&_ExposedPadlock_serviceDesc, srv)
}

func _ExposedPadlock_PostHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthHello)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostHello(ctx, req.(*AuthHello))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetApplicationListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationListModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).GetApplicationListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/GetApplicationListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).GetApplicationListModules(ctx, req.(*ApplicationListModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetApplicationConnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplicationConnectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExposedPadlockServer).GetApplicationConnect(m, &exposedPadlockGetApplicationConnectServer{stream})
}

type ExposedPadlock_GetApplicationConnectServer interface {
	Send(*ApplicationConnectUpdate) error
	grpc.ServerStream
}

type exposedPadlockGetApplicationConnectServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetApplicationConnectServer) Send(m *ApplicationConnectUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _ExposedPadlock_GetModuleListSlots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleListSlotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).GetModuleListSlots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/GetModuleListSlots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).GetModuleListSlots(ctx, req.(*ModuleListSlotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetModuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).GetModuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/GetModuleInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).GetModuleInfo(ctx, req.(*ModuleInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetSlotListMechanisms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlotListMechanismsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).GetSlotListMechanisms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/GetSlotListMechanisms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).GetSlotListMechanisms(ctx, req.(*SlotListMechanismsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PostSlotInitToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlotInitTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSlotInitToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSlotInitToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSlotInitToken(ctx, req.(*SlotInitTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetSlotOpenSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SlotOpenSessionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExposedPadlockServer).GetSlotOpenSession(m, &exposedPadlockGetSlotOpenSessionServer{stream})
}

type ExposedPadlock_GetSlotOpenSessionServer interface {
	Send(*SlotOpenSessionUpdate) error
	grpc.ServerStream
}

type exposedPadlockGetSlotOpenSessionServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetSlotOpenSessionServer) Send(m *SlotOpenSessionUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _ExposedPadlock_PostSessionKeepAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSessionKeepAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSessionKeepAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSessionKeepAlive(ctx, req.(*SessionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_DeleteSessionClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).DeleteSessionClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/DeleteSessionClose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).DeleteSessionClose(ctx, req.(*SessionCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PutSessionLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PutSessionLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PutSessionLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PutSessionLogin(ctx, req.(*SessionLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PutSessionLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PutSessionLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PutSessionLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PutSessionLogout(ctx, req.(*SessionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetSessionListObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionListObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExposedPadlockServer).GetSessionListObjects(m, &exposedPadlockGetSessionListObjectsServer{stream})
}

type ExposedPadlock_GetSessionListObjectsServer interface {
	Send(*P11Object) error
	grpc.ServerStream
}

type exposedPadlockGetSessionListObjectsServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetSessionListObjectsServer) Send(m *P11Object) error {
	return x.ServerStream.SendMsg(m)
}

func _ExposedPadlock_PostSessionCreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSessionCreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSessionCreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSessionCreateObject(ctx, req.(*SessionCreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PostSessionGenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSessionGenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSessionGenerateRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSessionGenerateRandom(ctx, req.(*SessionGenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PostSessionGenerateKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSessionGenerateKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSessionGenerateKeyPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSessionGenerateKeyPair(ctx, req.(*SessionGenerateKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PostSessionGenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSessionGenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSessionGenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSessionGenerateKey(ctx, req.(*SessionGenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetObjectListAttributeValues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObjectListAttributeValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExposedPadlockServer).GetObjectListAttributeValues(m, &exposedPadlockGetObjectListAttributeValuesServer{stream})
}

type ExposedPadlock_GetObjectListAttributeValuesServer interface {
	Send(*ObjectListAttributeValuesUpdate) error
	grpc.ServerStream
}

type exposedPadlockGetObjectListAttributeValuesServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetObjectListAttributeValuesServer) Send(m *ObjectListAttributeValuesUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _ExposedPadlock_PostEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostEncrypt(ctx, req.(*ObjectEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetEncryptSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExposedPadlockServer).GetEncryptSegmented(&exposedPadlockGetEncryptSegmentedServer{stream})
}

type ExposedPadlock_GetEncryptSegmentedServer interface {
	Send(*ObjectEncryptSegmentedResponse) error
	Recv() (*ObjectEncryptSegmentedRequest, error)
	grpc.ServerStream
}

type exposedPadlockGetEncryptSegmentedServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetEncryptSegmentedServer) Send(m *ObjectEncryptSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exposedPadlockGetEncryptSegmentedServer) Recv() (*ObjectEncryptSegmentedRequest, error) {
	m := new(ObjectEncryptSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExposedPadlock_PostDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostDecrypt(ctx, req.(*ObjectDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetDecryptSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExposedPadlockServer).GetDecryptSegmented(&exposedPadlockGetDecryptSegmentedServer{stream})
}

type ExposedPadlock_GetDecryptSegmentedServer interface {
	Send(*ObjectDecryptSegmentedResponse) error
	Recv() (*ObjectDecryptSegmentedRequest, error)
	grpc.ServerStream
}

type exposedPadlockGetDecryptSegmentedServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetDecryptSegmentedServer) Send(m *ObjectDecryptSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exposedPadlockGetDecryptSegmentedServer) Recv() (*ObjectDecryptSegmentedRequest, error) {
	m := new(ObjectDecryptSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExposedPadlock_PostSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostSign(ctx, req.(*ObjectSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetSignSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExposedPadlockServer).GetSignSegmented(&exposedPadlockGetSignSegmentedServer{stream})
}

type ExposedPadlock_GetSignSegmentedServer interface {
	SendAndClose(*ObjectSignSegmentedResponse) error
	Recv() (*ObjectSignSegmentedRequest, error)
	grpc.ServerStream
}

type exposedPadlockGetSignSegmentedServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetSignSegmentedServer) SendAndClose(m *ObjectSignSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exposedPadlockGetSignSegmentedServer) Recv() (*ObjectSignSegmentedRequest, error) {
	m := new(ObjectSignSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExposedPadlock_PostVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PostVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PostVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PostVerify(ctx, req.(*ObjectVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_GetVerifySegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExposedPadlockServer).GetVerifySegmented(&exposedPadlockGetVerifySegmentedServer{stream})
}

type ExposedPadlock_GetVerifySegmentedServer interface {
	SendAndClose(*ObjectVerifySegmentedResponse) error
	Recv() (*ObjectVerifySegmentedRequest, error)
	grpc.ServerStream
}

type exposedPadlockGetVerifySegmentedServer struct {
	grpc.ServerStream
}

func (x *exposedPadlockGetVerifySegmentedServer) SendAndClose(m *ObjectVerifySegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *exposedPadlockGetVerifySegmentedServer) Recv() (*ObjectVerifySegmentedRequest, error) {
	m := new(ObjectVerifySegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExposedPadlock_PutWrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectWrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PutWrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PutWrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PutWrapKey(ctx, req.(*ObjectWrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PutUnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectUnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PutUnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PutUnwrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PutUnwrapKey(ctx, req.(*ObjectUnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_DeleteDestroyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectDestroyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).DeleteDestroyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/DeleteDestroyObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).DeleteDestroyObject(ctx, req.(*ObjectDestroyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExposedPadlock_PutCopyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectCopyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExposedPadlockServer).PutCopyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.ExposedPadlock/PutCopyObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExposedPadlockServer).PutCopyObject(ctx, req.(*ObjectCopyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExposedPadlock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "padlock.ExposedPadlock",
	HandlerType: (*ExposedPadlockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostHello",
			Handler:    _ExposedPadlock_PostHello_Handler,
		},
		{
			MethodName: "GetApplicationListModules",
			Handler:    _ExposedPadlock_GetApplicationListModules_Handler,
		},
		{
			MethodName: "GetModuleListSlots",
			Handler:    _ExposedPadlock_GetModuleListSlots_Handler,
		},
		{
			MethodName: "GetModuleInfo",
			Handler:    _ExposedPadlock_GetModuleInfo_Handler,
		},
		{
			MethodName: "GetSlotListMechanisms",
			Handler:    _ExposedPadlock_GetSlotListMechanisms_Handler,
		},
		{
			MethodName: "PostSlotInitToken",
			Handler:    _ExposedPadlock_PostSlotInitToken_Handler,
		},
		{
			MethodName: "PostSessionKeepAlive",
			Handler:    _ExposedPadlock_PostSessionKeepAlive_Handler,
		},
		{
			MethodName: "DeleteSessionClose",
			Handler:    _ExposedPadlock_DeleteSessionClose_Handler,
		},
		{
			MethodName: "PutSessionLogin",
			Handler:    _ExposedPadlock_PutSessionLogin_Handler,
		},
		{
			MethodName: "PutSessionLogout",
			Handler:    _ExposedPadlock_PutSessionLogout_Handler,
		},
		{
			MethodName: "PostSessionCreateObject",
			Handler:    _ExposedPadlock_PostSessionCreateObject_Handler,
		},
		{
			MethodName: "PostSessionGenerateRandom",
			Handler:    _ExposedPadlock_PostSessionGenerateRandom_Handler,
		},
		{
			MethodName: "PostSessionGenerateKeyPair",
			Handler:    _ExposedPadlock_PostSessionGenerateKeyPair_Handler,
		},
		{
			MethodName: "PostSessionGenerateKey",
			Handler:    _ExposedPadlock_PostSessionGenerateKey_Handler,
		},
		{
			MethodName: "PostEncrypt",
			Handler:    _ExposedPadlock_PostEncrypt_Handler,
		},
		{
			MethodName: "PostDecrypt",
			Handler:    _ExposedPadlock_PostDecrypt_Handler,
		},
		{
			MethodName: "PostSign",
			Handler:    _ExposedPadlock_PostSign_Handler,
		},
		{
			MethodName: "PostVerify",
			Handler:    _ExposedPadlock_PostVerify_Handler,
		},
		{
			MethodName: "PutWrapKey",
			Handler:    _ExposedPadlock_PutWrapKey_Handler,
		},
		{
			MethodName: "PutUnwrapKey",
			Handler:    _ExposedPadlock_PutUnwrapKey_Handler,
		},
		{
			MethodName: "DeleteDestroyObject",
			Handler:    _ExposedPadlock_DeleteDestroyObject_Handler,
		},
		{
			MethodName: "PutCopyObject",
			Handler:    _ExposedPadlock_PutCopyObject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetApplicationConnect",
			Handler:       _ExposedPadlock_GetApplicationConnect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSlotOpenSession",
			Handler:       _ExposedPadlock_GetSlotOpenSession_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSessionListObjects",
			Handler:       _ExposedPadlock_GetSessionListObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetObjectListAttributeValues",
			Handler:       _ExposedPadlock_GetObjectListAttributeValues_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEncryptSegmented",
			Handler:       _ExposedPadlock_GetEncryptSegmented_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetDecryptSegmented",
			Handler:       _ExposedPadlock_GetDecryptSegmented_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetSignSegmented",
			Handler:       _ExposedPadlock_GetSignSegmented_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetVerifySegmented",
			Handler:       _ExposedPadlock_GetVerifySegmented_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "padlock.proto",
}

// PadlockClient is the client API for Padlock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PadlockClient interface {
	// Hello initiates a session with the application, generating an authentication token
	Hello(ctx context.Context, in *AuthHello, opts ...grpc.CallOption) (*AuthToken, error)
	// ApplicationListModules lists modules already connected to the application
	ApplicationListModules(ctx context.Context, in *ApplicationListModulesRequest, opts ...grpc.CallOption) (*ApplicationListModulesResponse, error)
	// ApplicationConnect connects a new module to the application
	ApplicationConnect(ctx context.Context, in *ApplicationConnectRequest, opts ...grpc.CallOption) (Padlock_ApplicationConnectClient, error)
	// ModuleListSlots lists the slots on a module
	ModuleListSlots(ctx context.Context, in *ModuleListSlotsRequest, opts ...grpc.CallOption) (*ModuleListSlotsResponse, error)
	// ModuleInfo gets info for a specific module
	ModuleInfo(ctx context.Context, in *ModuleInfoRequest, opts ...grpc.CallOption) (*ModuleInfoResponse, error)
	// SlotListMechanisms lists the mechanisms available on a slot
	SlotListMechanisms(ctx context.Context, in *SlotListMechanismsRequest, opts ...grpc.CallOption) (*SlotListMechanismsResponse, error)
	// SlotInitToken creates the token in the slot
	SlotInitToken(ctx context.Context, in *SlotInitTokenRequest, opts ...grpc.CallOption) (*SlotInitTokenResponse, error)
	// SlotOpenSession creates a session on the slot
	SlotOpenSession(ctx context.Context, in *SlotOpenSessionRequest, opts ...grpc.CallOption) (Padlock_SlotOpenSessionClient, error)
	// SessionKeepalive keeps a session alive without taking any action agains the HSM itself
	SessionKeepAlive(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*empty.Empty, error)
	// SessionClose closes the session
	SessionClose(ctx context.Context, in *SessionCloseRequest, opts ...grpc.CallOption) (*SessionCloseResponse, error)
	// SessionLogin logs into the session at the application level
	SessionLogin(ctx context.Context, in *SessionLoginRequest, opts ...grpc.CallOption) (*SessionLoginResponse, error)
	// SessionLogout logs out of the session at the application level
	SessionLogout(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*SessionLogoutResponse, error)
	// SessionListObjects lists the objects available in the session
	SessionListObjects(ctx context.Context, in *SessionListObjectsRequest, opts ...grpc.CallOption) (Padlock_SessionListObjectsClient, error)
	// SessionCreateObject creates an object
	SessionCreateObject(ctx context.Context, in *SessionCreateObjectRequest, opts ...grpc.CallOption) (*P11Object, error)
	// SessionGenerateRandom generates random data, exercising the CSPRNG
	SessionGenerateRandom(ctx context.Context, in *SessionGenerateRandomRequest, opts ...grpc.CallOption) (*SessionGenerateRandomResponse, error)
	// SessionGenerateKeyPair generates a keypair
	SessionGenerateKeyPair(ctx context.Context, in *SessionGenerateKeyPairRequest, opts ...grpc.CallOption) (*SessionGenerateKeyPairResponse, error)
	// SessionGenerateKey generates a key
	SessionGenerateKey(ctx context.Context, in *SessionGenerateKeyRequest, opts ...grpc.CallOption) (*P11Object, error)
	// ObjectListAttributeValues lists values for the requested attributes
	ObjectListAttributeValues(ctx context.Context, in *ObjectListAttributeValuesRequest, opts ...grpc.CallOption) (Padlock_ObjectListAttributeValuesClient, error)
	// ObjectSetAttributeValues attempts to set specific attributes and values
	ObjectSetAttributeValues(ctx context.Context, in *ObjectSetAttributeValuesRequest, opts ...grpc.CallOption) (*ObjectSetAttributeValuesResponse, error)
	// Encrypt encrypts data
	Encrypt(ctx context.Context, in *ObjectEncryptRequest, opts ...grpc.CallOption) (*ObjectEncryptResponse, error)
	// EncryptSegmented encrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	EncryptSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_EncryptSegmentedClient, error)
	// Decrypt decrypts data
	Decrypt(ctx context.Context, in *ObjectDecryptRequest, opts ...grpc.CallOption) (*ObjectDecryptResponse, error)
	// DecryptSegmented decrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	DecryptSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_DecryptSegmentedClient, error)
	// Sign signs a message
	Sign(ctx context.Context, in *ObjectSignRequest, opts ...grpc.CallOption) (*ObjectSignResponse, error)
	// SignSegmented signs multiple data segments individually then one final part, for those few mechanisms where it matters
	SignSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_SignSegmentedClient, error)
	// Verify verifies a message and signature
	Verify(ctx context.Context, in *ObjectVerifyRequest, opts ...grpc.CallOption) (*ObjectVerifyResponse, error)
	// VerifySegmented verifies multiple data segments individually then the final signature, for those  few mechanisms where it matters.
	VerifySegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_VerifySegmentedClient, error)
	// WrapKey wraps a key
	WrapKey(ctx context.Context, in *ObjectWrapKeyRequest, opts ...grpc.CallOption) (*ObjectWrapKeyResponse, error)
	// UnwrapKey unwraps a key
	UnwrapKey(ctx context.Context, in *ObjectUnwrapKeyRequest, opts ...grpc.CallOption) (*P11Object, error)
	// DestroyObject destroys an object
	DestroyObject(ctx context.Context, in *ObjectDestroyObjectRequest, opts ...grpc.CallOption) (*ObjectDestroyObjectResponse, error)
	// CopyObject copies an object with new attributes if possible
	CopyObject(ctx context.Context, in *ObjectCopyObjectRequest, opts ...grpc.CallOption) (*P11Object, error)
}

type padlockClient struct {
	cc grpc.ClientConnInterface
}

func NewPadlockClient(cc grpc.ClientConnInterface) PadlockClient {
	return &padlockClient{cc}
}

func (c *padlockClient) Hello(ctx context.Context, in *AuthHello, opts ...grpc.CallOption) (*AuthToken, error) {
	out := new(AuthToken)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/Hello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) ApplicationListModules(ctx context.Context, in *ApplicationListModulesRequest, opts ...grpc.CallOption) (*ApplicationListModulesResponse, error) {
	out := new(ApplicationListModulesResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/ApplicationListModules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) ApplicationConnect(ctx context.Context, in *ApplicationConnectRequest, opts ...grpc.CallOption) (Padlock_ApplicationConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[0], "/padlock.Padlock/ApplicationConnect", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockApplicationConnectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Padlock_ApplicationConnectClient interface {
	Recv() (*ApplicationConnectUpdate, error)
	grpc.ClientStream
}

type padlockApplicationConnectClient struct {
	grpc.ClientStream
}

func (x *padlockApplicationConnectClient) Recv() (*ApplicationConnectUpdate, error) {
	m := new(ApplicationConnectUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) ModuleListSlots(ctx context.Context, in *ModuleListSlotsRequest, opts ...grpc.CallOption) (*ModuleListSlotsResponse, error) {
	out := new(ModuleListSlotsResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/ModuleListSlots", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) ModuleInfo(ctx context.Context, in *ModuleInfoRequest, opts ...grpc.CallOption) (*ModuleInfoResponse, error) {
	out := new(ModuleInfoResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/ModuleInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SlotListMechanisms(ctx context.Context, in *SlotListMechanismsRequest, opts ...grpc.CallOption) (*SlotListMechanismsResponse, error) {
	out := new(SlotListMechanismsResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SlotListMechanisms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SlotInitToken(ctx context.Context, in *SlotInitTokenRequest, opts ...grpc.CallOption) (*SlotInitTokenResponse, error) {
	out := new(SlotInitTokenResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SlotInitToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SlotOpenSession(ctx context.Context, in *SlotOpenSessionRequest, opts ...grpc.CallOption) (Padlock_SlotOpenSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[1], "/padlock.Padlock/SlotOpenSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockSlotOpenSessionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Padlock_SlotOpenSessionClient interface {
	Recv() (*SlotOpenSessionUpdate, error)
	grpc.ClientStream
}

type padlockSlotOpenSessionClient struct {
	grpc.ClientStream
}

func (x *padlockSlotOpenSessionClient) Recv() (*SlotOpenSessionUpdate, error) {
	m := new(SlotOpenSessionUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) SessionKeepAlive(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionKeepAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionClose(ctx context.Context, in *SessionCloseRequest, opts ...grpc.CallOption) (*SessionCloseResponse, error) {
	out := new(SessionCloseResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionClose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionLogin(ctx context.Context, in *SessionLoginRequest, opts ...grpc.CallOption) (*SessionLoginResponse, error) {
	out := new(SessionLoginResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionLogout(ctx context.Context, in *SessionID, opts ...grpc.CallOption) (*SessionLogoutResponse, error) {
	out := new(SessionLogoutResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionLogout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionListObjects(ctx context.Context, in *SessionListObjectsRequest, opts ...grpc.CallOption) (Padlock_SessionListObjectsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[2], "/padlock.Padlock/SessionListObjects", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockSessionListObjectsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Padlock_SessionListObjectsClient interface {
	Recv() (*P11Object, error)
	grpc.ClientStream
}

type padlockSessionListObjectsClient struct {
	grpc.ClientStream
}

func (x *padlockSessionListObjectsClient) Recv() (*P11Object, error) {
	m := new(P11Object)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) SessionCreateObject(ctx context.Context, in *SessionCreateObjectRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionCreateObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionGenerateRandom(ctx context.Context, in *SessionGenerateRandomRequest, opts ...grpc.CallOption) (*SessionGenerateRandomResponse, error) {
	out := new(SessionGenerateRandomResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionGenerateRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionGenerateKeyPair(ctx context.Context, in *SessionGenerateKeyPairRequest, opts ...grpc.CallOption) (*SessionGenerateKeyPairResponse, error) {
	out := new(SessionGenerateKeyPairResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionGenerateKeyPair", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SessionGenerateKey(ctx context.Context, in *SessionGenerateKeyRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/SessionGenerateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) ObjectListAttributeValues(ctx context.Context, in *ObjectListAttributeValuesRequest, opts ...grpc.CallOption) (Padlock_ObjectListAttributeValuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[3], "/padlock.Padlock/ObjectListAttributeValues", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockObjectListAttributeValuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Padlock_ObjectListAttributeValuesClient interface {
	Recv() (*ObjectListAttributeValuesUpdate, error)
	grpc.ClientStream
}

type padlockObjectListAttributeValuesClient struct {
	grpc.ClientStream
}

func (x *padlockObjectListAttributeValuesClient) Recv() (*ObjectListAttributeValuesUpdate, error) {
	m := new(ObjectListAttributeValuesUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) ObjectSetAttributeValues(ctx context.Context, in *ObjectSetAttributeValuesRequest, opts ...grpc.CallOption) (*ObjectSetAttributeValuesResponse, error) {
	out := new(ObjectSetAttributeValuesResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/ObjectSetAttributeValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) Encrypt(ctx context.Context, in *ObjectEncryptRequest, opts ...grpc.CallOption) (*ObjectEncryptResponse, error) {
	out := new(ObjectEncryptResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/Encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) EncryptSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_EncryptSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[4], "/padlock.Padlock/EncryptSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockEncryptSegmentedClient{stream}
	return x, nil
}

type Padlock_EncryptSegmentedClient interface {
	Send(*ObjectEncryptSegmentedRequest) error
	Recv() (*ObjectEncryptSegmentedResponse, error)
	grpc.ClientStream
}

type padlockEncryptSegmentedClient struct {
	grpc.ClientStream
}

func (x *padlockEncryptSegmentedClient) Send(m *ObjectEncryptSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *padlockEncryptSegmentedClient) Recv() (*ObjectEncryptSegmentedResponse, error) {
	m := new(ObjectEncryptSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) Decrypt(ctx context.Context, in *ObjectDecryptRequest, opts ...grpc.CallOption) (*ObjectDecryptResponse, error) {
	out := new(ObjectDecryptResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/Decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) DecryptSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_DecryptSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[5], "/padlock.Padlock/DecryptSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockDecryptSegmentedClient{stream}
	return x, nil
}

type Padlock_DecryptSegmentedClient interface {
	Send(*ObjectDecryptSegmentedRequest) error
	Recv() (*ObjectDecryptSegmentedResponse, error)
	grpc.ClientStream
}

type padlockDecryptSegmentedClient struct {
	grpc.ClientStream
}

func (x *padlockDecryptSegmentedClient) Send(m *ObjectDecryptSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *padlockDecryptSegmentedClient) Recv() (*ObjectDecryptSegmentedResponse, error) {
	m := new(ObjectDecryptSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) Sign(ctx context.Context, in *ObjectSignRequest, opts ...grpc.CallOption) (*ObjectSignResponse, error) {
	out := new(ObjectSignResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) SignSegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_SignSegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[6], "/padlock.Padlock/SignSegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockSignSegmentedClient{stream}
	return x, nil
}

type Padlock_SignSegmentedClient interface {
	Send(*ObjectSignSegmentedRequest) error
	CloseAndRecv() (*ObjectSignSegmentedResponse, error)
	grpc.ClientStream
}

type padlockSignSegmentedClient struct {
	grpc.ClientStream
}

func (x *padlockSignSegmentedClient) Send(m *ObjectSignSegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *padlockSignSegmentedClient) CloseAndRecv() (*ObjectSignSegmentedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectSignSegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) Verify(ctx context.Context, in *ObjectVerifyRequest, opts ...grpc.CallOption) (*ObjectVerifyResponse, error) {
	out := new(ObjectVerifyResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) VerifySegmented(ctx context.Context, opts ...grpc.CallOption) (Padlock_VerifySegmentedClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Padlock_serviceDesc.Streams[7], "/padlock.Padlock/VerifySegmented", opts...)
	if err != nil {
		return nil, err
	}
	x := &padlockVerifySegmentedClient{stream}
	return x, nil
}

type Padlock_VerifySegmentedClient interface {
	Send(*ObjectVerifySegmentedRequest) error
	CloseAndRecv() (*ObjectVerifySegmentedResponse, error)
	grpc.ClientStream
}

type padlockVerifySegmentedClient struct {
	grpc.ClientStream
}

func (x *padlockVerifySegmentedClient) Send(m *ObjectVerifySegmentedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *padlockVerifySegmentedClient) CloseAndRecv() (*ObjectVerifySegmentedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ObjectVerifySegmentedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *padlockClient) WrapKey(ctx context.Context, in *ObjectWrapKeyRequest, opts ...grpc.CallOption) (*ObjectWrapKeyResponse, error) {
	out := new(ObjectWrapKeyResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/WrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) UnwrapKey(ctx context.Context, in *ObjectUnwrapKeyRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/UnwrapKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) DestroyObject(ctx context.Context, in *ObjectDestroyObjectRequest, opts ...grpc.CallOption) (*ObjectDestroyObjectResponse, error) {
	out := new(ObjectDestroyObjectResponse)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/DestroyObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *padlockClient) CopyObject(ctx context.Context, in *ObjectCopyObjectRequest, opts ...grpc.CallOption) (*P11Object, error) {
	out := new(P11Object)
	err := c.cc.Invoke(ctx, "/padlock.Padlock/CopyObject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PadlockServer is the server API for Padlock service.
// All implementations must embed UnimplementedPadlockServer
// for forward compatibility
type PadlockServer interface {
	// Hello initiates a session with the application, generating an authentication token
	Hello(context.Context, *AuthHello) (*AuthToken, error)
	// ApplicationListModules lists modules already connected to the application
	ApplicationListModules(context.Context, *ApplicationListModulesRequest) (*ApplicationListModulesResponse, error)
	// ApplicationConnect connects a new module to the application
	ApplicationConnect(*ApplicationConnectRequest, Padlock_ApplicationConnectServer) error
	// ModuleListSlots lists the slots on a module
	ModuleListSlots(context.Context, *ModuleListSlotsRequest) (*ModuleListSlotsResponse, error)
	// ModuleInfo gets info for a specific module
	ModuleInfo(context.Context, *ModuleInfoRequest) (*ModuleInfoResponse, error)
	// SlotListMechanisms lists the mechanisms available on a slot
	SlotListMechanisms(context.Context, *SlotListMechanismsRequest) (*SlotListMechanismsResponse, error)
	// SlotInitToken creates the token in the slot
	SlotInitToken(context.Context, *SlotInitTokenRequest) (*SlotInitTokenResponse, error)
	// SlotOpenSession creates a session on the slot
	SlotOpenSession(*SlotOpenSessionRequest, Padlock_SlotOpenSessionServer) error
	// SessionKeepalive keeps a session alive without taking any action agains the HSM itself
	SessionKeepAlive(context.Context, *SessionID) (*empty.Empty, error)
	// SessionClose closes the session
	SessionClose(context.Context, *SessionCloseRequest) (*SessionCloseResponse, error)
	// SessionLogin logs into the session at the application level
	SessionLogin(context.Context, *SessionLoginRequest) (*SessionLoginResponse, error)
	// SessionLogout logs out of the session at the application level
	SessionLogout(context.Context, *SessionID) (*SessionLogoutResponse, error)
	// SessionListObjects lists the objects available in the session
	SessionListObjects(*SessionListObjectsRequest, Padlock_SessionListObjectsServer) error
	// SessionCreateObject creates an object
	SessionCreateObject(context.Context, *SessionCreateObjectRequest) (*P11Object, error)
	// SessionGenerateRandom generates random data, exercising the CSPRNG
	SessionGenerateRandom(context.Context, *SessionGenerateRandomRequest) (*SessionGenerateRandomResponse, error)
	// SessionGenerateKeyPair generates a keypair
	SessionGenerateKeyPair(context.Context, *SessionGenerateKeyPairRequest) (*SessionGenerateKeyPairResponse, error)
	// SessionGenerateKey generates a key
	SessionGenerateKey(context.Context, *SessionGenerateKeyRequest) (*P11Object, error)
	// ObjectListAttributeValues lists values for the requested attributes
	ObjectListAttributeValues(*ObjectListAttributeValuesRequest, Padlock_ObjectListAttributeValuesServer) error
	// ObjectSetAttributeValues attempts to set specific attributes and values
	ObjectSetAttributeValues(context.Context, *ObjectSetAttributeValuesRequest) (*ObjectSetAttributeValuesResponse, error)
	// Encrypt encrypts data
	Encrypt(context.Context, *ObjectEncryptRequest) (*ObjectEncryptResponse, error)
	// EncryptSegmented encrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	EncryptSegmented(Padlock_EncryptSegmentedServer) error
	// Decrypt decrypts data
	Decrypt(context.Context, *ObjectDecryptRequest) (*ObjectDecryptResponse, error)
	// DecryptSegmented decrypts multiple data segments individually then one final one, for those few mechanisms where it matters
	DecryptSegmented(Padlock_DecryptSegmentedServer) error
	// Sign signs a message
	Sign(context.Context, *ObjectSignRequest) (*ObjectSignResponse, error)
	// SignSegmented signs multiple data segments individually then one final part, for those few mechanisms where it matters
	SignSegmented(Padlock_SignSegmentedServer) error
	// Verify verifies a message and signature
	Verify(context.Context, *ObjectVerifyRequest) (*ObjectVerifyResponse, error)
	// VerifySegmented verifies multiple data segments individually then the final signature, for those  few mechanisms where it matters.
	VerifySegmented(Padlock_VerifySegmentedServer) error
	// WrapKey wraps a key
	WrapKey(context.Context, *ObjectWrapKeyRequest) (*ObjectWrapKeyResponse, error)
	// UnwrapKey unwraps a key
	UnwrapKey(context.Context, *ObjectUnwrapKeyRequest) (*P11Object, error)
	// DestroyObject destroys an object
	DestroyObject(context.Context, *ObjectDestroyObjectRequest) (*ObjectDestroyObjectResponse, error)
	// CopyObject copies an object with new attributes if possible
	CopyObject(context.Context, *ObjectCopyObjectRequest) (*P11Object, error)
	mustEmbedUnimplementedPadlockServer()
}

// UnimplementedPadlockServer must be embedded to have forward compatible implementations.
type UnimplementedPadlockServer struct {
}

func (UnimplementedPadlockServer) Hello(context.Context, *AuthHello) (*AuthToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hello not implemented")
}
func (UnimplementedPadlockServer) ApplicationListModules(context.Context, *ApplicationListModulesRequest) (*ApplicationListModulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplicationListModules not implemented")
}
func (UnimplementedPadlockServer) ApplicationConnect(*ApplicationConnectRequest, Padlock_ApplicationConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method ApplicationConnect not implemented")
}
func (UnimplementedPadlockServer) ModuleListSlots(context.Context, *ModuleListSlotsRequest) (*ModuleListSlotsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleListSlots not implemented")
}
func (UnimplementedPadlockServer) ModuleInfo(context.Context, *ModuleInfoRequest) (*ModuleInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfo not implemented")
}
func (UnimplementedPadlockServer) SlotListMechanisms(context.Context, *SlotListMechanismsRequest) (*SlotListMechanismsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SlotListMechanisms not implemented")
}
func (UnimplementedPadlockServer) SlotInitToken(context.Context, *SlotInitTokenRequest) (*SlotInitTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SlotInitToken not implemented")
}
func (UnimplementedPadlockServer) SlotOpenSession(*SlotOpenSessionRequest, Padlock_SlotOpenSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method SlotOpenSession not implemented")
}
func (UnimplementedPadlockServer) SessionKeepAlive(context.Context, *SessionID) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionKeepAlive not implemented")
}
func (UnimplementedPadlockServer) SessionClose(context.Context, *SessionCloseRequest) (*SessionCloseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionClose not implemented")
}
func (UnimplementedPadlockServer) SessionLogin(context.Context, *SessionLoginRequest) (*SessionLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionLogin not implemented")
}
func (UnimplementedPadlockServer) SessionLogout(context.Context, *SessionID) (*SessionLogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionLogout not implemented")
}
func (UnimplementedPadlockServer) SessionListObjects(*SessionListObjectsRequest, Padlock_SessionListObjectsServer) error {
	return status.Errorf(codes.Unimplemented, "method SessionListObjects not implemented")
}
func (UnimplementedPadlockServer) SessionCreateObject(context.Context, *SessionCreateObjectRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionCreateObject not implemented")
}
func (UnimplementedPadlockServer) SessionGenerateRandom(context.Context, *SessionGenerateRandomRequest) (*SessionGenerateRandomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionGenerateRandom not implemented")
}
func (UnimplementedPadlockServer) SessionGenerateKeyPair(context.Context, *SessionGenerateKeyPairRequest) (*SessionGenerateKeyPairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionGenerateKeyPair not implemented")
}
func (UnimplementedPadlockServer) SessionGenerateKey(context.Context, *SessionGenerateKeyRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SessionGenerateKey not implemented")
}
func (UnimplementedPadlockServer) ObjectListAttributeValues(*ObjectListAttributeValuesRequest, Padlock_ObjectListAttributeValuesServer) error {
	return status.Errorf(codes.Unimplemented, "method ObjectListAttributeValues not implemented")
}
func (UnimplementedPadlockServer) ObjectSetAttributeValues(context.Context, *ObjectSetAttributeValuesRequest) (*ObjectSetAttributeValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObjectSetAttributeValues not implemented")
}
func (UnimplementedPadlockServer) Encrypt(context.Context, *ObjectEncryptRequest) (*ObjectEncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedPadlockServer) EncryptSegmented(Padlock_EncryptSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method EncryptSegmented not implemented")
}
func (UnimplementedPadlockServer) Decrypt(context.Context, *ObjectDecryptRequest) (*ObjectDecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedPadlockServer) DecryptSegmented(Padlock_DecryptSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method DecryptSegmented not implemented")
}
func (UnimplementedPadlockServer) Sign(context.Context, *ObjectSignRequest) (*ObjectSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedPadlockServer) SignSegmented(Padlock_SignSegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method SignSegmented not implemented")
}
func (UnimplementedPadlockServer) Verify(context.Context, *ObjectVerifyRequest) (*ObjectVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedPadlockServer) VerifySegmented(Padlock_VerifySegmentedServer) error {
	return status.Errorf(codes.Unimplemented, "method VerifySegmented not implemented")
}
func (UnimplementedPadlockServer) WrapKey(context.Context, *ObjectWrapKeyRequest) (*ObjectWrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WrapKey not implemented")
}
func (UnimplementedPadlockServer) UnwrapKey(context.Context, *ObjectUnwrapKeyRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (UnimplementedPadlockServer) DestroyObject(context.Context, *ObjectDestroyObjectRequest) (*ObjectDestroyObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyObject not implemented")
}
func (UnimplementedPadlockServer) CopyObject(context.Context, *ObjectCopyObjectRequest) (*P11Object, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyObject not implemented")
}
func (UnimplementedPadlockServer) mustEmbedUnimplementedPadlockServer() {}

// UnsafePadlockServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PadlockServer will
// result in compilation errors.
type UnsafePadlockServer interface {
	mustEmbedUnimplementedPadlockServer()
}

func RegisterPadlockServer(s *grpc.Server, srv PadlockServer) {
	s.RegisterService(&_Padlock_serviceDesc, srv)
}

func _Padlock_Hello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthHello)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).Hello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/Hello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).Hello(ctx, req.(*AuthHello))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_ApplicationListModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationListModulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).ApplicationListModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/ApplicationListModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).ApplicationListModules(ctx, req.(*ApplicationListModulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_ApplicationConnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ApplicationConnectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PadlockServer).ApplicationConnect(m, &padlockApplicationConnectServer{stream})
}

type Padlock_ApplicationConnectServer interface {
	Send(*ApplicationConnectUpdate) error
	grpc.ServerStream
}

type padlockApplicationConnectServer struct {
	grpc.ServerStream
}

func (x *padlockApplicationConnectServer) Send(m *ApplicationConnectUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Padlock_ModuleListSlots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleListSlotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).ModuleListSlots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/ModuleListSlots",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).ModuleListSlots(ctx, req.(*ModuleListSlotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_ModuleInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).ModuleInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/ModuleInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).ModuleInfo(ctx, req.(*ModuleInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SlotListMechanisms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlotListMechanismsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SlotListMechanisms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SlotListMechanisms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SlotListMechanisms(ctx, req.(*SlotListMechanismsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SlotInitToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SlotInitTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SlotInitToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SlotInitToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SlotInitToken(ctx, req.(*SlotInitTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SlotOpenSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SlotOpenSessionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PadlockServer).SlotOpenSession(m, &padlockSlotOpenSessionServer{stream})
}

type Padlock_SlotOpenSessionServer interface {
	Send(*SlotOpenSessionUpdate) error
	grpc.ServerStream
}

type padlockSlotOpenSessionServer struct {
	grpc.ServerStream
}

func (x *padlockSlotOpenSessionServer) Send(m *SlotOpenSessionUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Padlock_SessionKeepAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionKeepAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionKeepAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionKeepAlive(ctx, req.(*SessionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionClose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCloseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionClose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionClose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionClose(ctx, req.(*SessionCloseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionLogin(ctx, req.(*SessionLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionLogout(ctx, req.(*SessionID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionListObjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionListObjectsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PadlockServer).SessionListObjects(m, &padlockSessionListObjectsServer{stream})
}

type Padlock_SessionListObjectsServer interface {
	Send(*P11Object) error
	grpc.ServerStream
}

type padlockSessionListObjectsServer struct {
	grpc.ServerStream
}

func (x *padlockSessionListObjectsServer) Send(m *P11Object) error {
	return x.ServerStream.SendMsg(m)
}

func _Padlock_SessionCreateObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionCreateObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionCreateObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionCreateObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionCreateObject(ctx, req.(*SessionCreateObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionGenerateRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateRandomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionGenerateRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionGenerateRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionGenerateRandom(ctx, req.(*SessionGenerateRandomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionGenerateKeyPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateKeyPairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionGenerateKeyPair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionGenerateKeyPair",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionGenerateKeyPair(ctx, req.(*SessionGenerateKeyPairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SessionGenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionGenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).SessionGenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/SessionGenerateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).SessionGenerateKey(ctx, req.(*SessionGenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_ObjectListAttributeValues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObjectListAttributeValuesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PadlockServer).ObjectListAttributeValues(m, &padlockObjectListAttributeValuesServer{stream})
}

type Padlock_ObjectListAttributeValuesServer interface {
	Send(*ObjectListAttributeValuesUpdate) error
	grpc.ServerStream
}

type padlockObjectListAttributeValuesServer struct {
	grpc.ServerStream
}

func (x *padlockObjectListAttributeValuesServer) Send(m *ObjectListAttributeValuesUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func _Padlock_ObjectSetAttributeValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectSetAttributeValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).ObjectSetAttributeValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/ObjectSetAttributeValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).ObjectSetAttributeValues(ctx, req.(*ObjectSetAttributeValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectEncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/Encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).Encrypt(ctx, req.(*ObjectEncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_EncryptSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PadlockServer).EncryptSegmented(&padlockEncryptSegmentedServer{stream})
}

type Padlock_EncryptSegmentedServer interface {
	Send(*ObjectEncryptSegmentedResponse) error
	Recv() (*ObjectEncryptSegmentedRequest, error)
	grpc.ServerStream
}

type padlockEncryptSegmentedServer struct {
	grpc.ServerStream
}

func (x *padlockEncryptSegmentedServer) Send(m *ObjectEncryptSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *padlockEncryptSegmentedServer) Recv() (*ObjectEncryptSegmentedRequest, error) {
	m := new(ObjectEncryptSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Padlock_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectDecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/Decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).Decrypt(ctx, req.(*ObjectDecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_DecryptSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PadlockServer).DecryptSegmented(&padlockDecryptSegmentedServer{stream})
}

type Padlock_DecryptSegmentedServer interface {
	Send(*ObjectDecryptSegmentedResponse) error
	Recv() (*ObjectDecryptSegmentedRequest, error)
	grpc.ServerStream
}

type padlockDecryptSegmentedServer struct {
	grpc.ServerStream
}

func (x *padlockDecryptSegmentedServer) Send(m *ObjectDecryptSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *padlockDecryptSegmentedServer) Recv() (*ObjectDecryptSegmentedRequest, error) {
	m := new(ObjectDecryptSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Padlock_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).Sign(ctx, req.(*ObjectSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_SignSegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PadlockServer).SignSegmented(&padlockSignSegmentedServer{stream})
}

type Padlock_SignSegmentedServer interface {
	SendAndClose(*ObjectSignSegmentedResponse) error
	Recv() (*ObjectSignSegmentedRequest, error)
	grpc.ServerStream
}

type padlockSignSegmentedServer struct {
	grpc.ServerStream
}

func (x *padlockSignSegmentedServer) SendAndClose(m *ObjectSignSegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *padlockSignSegmentedServer) Recv() (*ObjectSignSegmentedRequest, error) {
	m := new(ObjectSignSegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Padlock_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).Verify(ctx, req.(*ObjectVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_VerifySegmented_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(PadlockServer).VerifySegmented(&padlockVerifySegmentedServer{stream})
}

type Padlock_VerifySegmentedServer interface {
	SendAndClose(*ObjectVerifySegmentedResponse) error
	Recv() (*ObjectVerifySegmentedRequest, error)
	grpc.ServerStream
}

type padlockVerifySegmentedServer struct {
	grpc.ServerStream
}

func (x *padlockVerifySegmentedServer) SendAndClose(m *ObjectVerifySegmentedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *padlockVerifySegmentedServer) Recv() (*ObjectVerifySegmentedRequest, error) {
	m := new(ObjectVerifySegmentedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Padlock_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectWrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/WrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).WrapKey(ctx, req.(*ObjectWrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectUnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/UnwrapKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).UnwrapKey(ctx, req.(*ObjectUnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_DestroyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectDestroyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).DestroyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/DestroyObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).DestroyObject(ctx, req.(*ObjectDestroyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Padlock_CopyObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectCopyObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PadlockServer).CopyObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/padlock.Padlock/CopyObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PadlockServer).CopyObject(ctx, req.(*ObjectCopyObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Padlock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "padlock.Padlock",
	HandlerType: (*PadlockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Hello",
			Handler:    _Padlock_Hello_Handler,
		},
		{
			MethodName: "ApplicationListModules",
			Handler:    _Padlock_ApplicationListModules_Handler,
		},
		{
			MethodName: "ModuleListSlots",
			Handler:    _Padlock_ModuleListSlots_Handler,
		},
		{
			MethodName: "ModuleInfo",
			Handler:    _Padlock_ModuleInfo_Handler,
		},
		{
			MethodName: "SlotListMechanisms",
			Handler:    _Padlock_SlotListMechanisms_Handler,
		},
		{
			MethodName: "SlotInitToken",
			Handler:    _Padlock_SlotInitToken_Handler,
		},
		{
			MethodName: "SessionKeepAlive",
			Handler:    _Padlock_SessionKeepAlive_Handler,
		},
		{
			MethodName: "SessionClose",
			Handler:    _Padlock_SessionClose_Handler,
		},
		{
			MethodName: "SessionLogin",
			Handler:    _Padlock_SessionLogin_Handler,
		},
		{
			MethodName: "SessionLogout",
			Handler:    _Padlock_SessionLogout_Handler,
		},
		{
			MethodName: "SessionCreateObject",
			Handler:    _Padlock_SessionCreateObject_Handler,
		},
		{
			MethodName: "SessionGenerateRandom",
			Handler:    _Padlock_SessionGenerateRandom_Handler,
		},
		{
			MethodName: "SessionGenerateKeyPair",
			Handler:    _Padlock_SessionGenerateKeyPair_Handler,
		},
		{
			MethodName: "SessionGenerateKey",
			Handler:    _Padlock_SessionGenerateKey_Handler,
		},
		{
			MethodName: "ObjectSetAttributeValues",
			Handler:    _Padlock_ObjectSetAttributeValues_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Padlock_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Padlock_Decrypt_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Padlock_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _Padlock_Verify_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _Padlock_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _Padlock_UnwrapKey_Handler,
		},
		{
			MethodName: "DestroyObject",
			Handler:    _Padlock_DestroyObject_Handler,
		},
		{
			MethodName: "CopyObject",
			Handler:    _Padlock_CopyObject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ApplicationConnect",
			Handler:       _Padlock_ApplicationConnect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SlotOpenSession",
			Handler:       _Padlock_SlotOpenSession_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SessionListObjects",
			Handler:       _Padlock_SessionListObjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ObjectListAttributeValues",
			Handler:       _Padlock_ObjectListAttributeValues_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EncryptSegmented",
			Handler:       _Padlock_EncryptSegmented_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DecryptSegmented",
			Handler:       _Padlock_DecryptSegmented_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SignSegmented",
			Handler:       _Padlock_SignSegmented_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifySegmented",
			Handler:       _Padlock_VerifySegmented_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "padlock.proto",
}
