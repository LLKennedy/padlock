/**
 * Code generated by protoc-gen-tsjson. DO NOT EDIT.
 * versions:
 * 	protoc-gen-tsjson v0.5.2
 * 	protoc            v3.10.1
 * source: pkcs11.proto
 */

import * as tsjson from "@llkennedy/protoc-gen-tsjson";
import { MechanismType as padlock__MechanismType } from "./mechanisms";
import { AttributeType as padlock__AttributeType } from "./attributes";

/** A message */
export class ModuleInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public cryptokiVersion?: Version;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public libraryDescription?: string;
	/** A field */
	public libraryVersion?: Version;
	public ToProtoJSON(): Object {
		return {
			cryptokiVersion: this.cryptokiVersion?.ToProtoJSON(),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			libraryDescription: tsjson.ToProtoJSON.String(this.libraryDescription),
			libraryVersion: this.libraryVersion?.ToProtoJSON(),
		};
	}
	public static async Parse(data: any): Promise<ModuleInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new ModuleInfo();
		res.cryptokiVersion = await tsjson.Parse.Message(objData, "cryptokiVersion", "cryptoki_version", Version.Parse);
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.libraryDescription = await tsjson.Parse.String(objData, "libraryDescription", "library_description");
		res.libraryVersion = await tsjson.Parse.Message(objData, "libraryVersion", "library_version", Version.Parse);
		return res;
	}
}

/** A message */
export class SlotInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public id?: number;
	/** A field */
	public slotDescription?: string;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public hardwareVersion?: Version;
	/** A field */
	public firmwareVersion?: Version;
	/** A field */
	public tokenInfo?: TokenInfo;
	public ToProtoJSON(): Object {
		return {
			id: tsjson.ToProtoJSON.StringNumber(this.id),
			slotDescription: tsjson.ToProtoJSON.String(this.slotDescription),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			hardwareVersion: this.hardwareVersion?.ToProtoJSON(),
			firmwareVersion: this.firmwareVersion?.ToProtoJSON(),
			tokenInfo: this.tokenInfo?.ToProtoJSON(),
		};
	}
	public static async Parse(data: any): Promise<SlotInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new SlotInfo();
		res.id = await tsjson.Parse.Number(objData, "id", "id");
		res.slotDescription = await tsjson.Parse.String(objData, "slotDescription", "slot_description");
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.hardwareVersion = await tsjson.Parse.Message(objData, "hardwareVersion", "hardware_version", Version.Parse);
		res.firmwareVersion = await tsjson.Parse.Message(objData, "firmwareVersion", "firmware_version", Version.Parse);
		res.tokenInfo = await tsjson.Parse.Message(objData, "tokenInfo", "token_info", TokenInfo.Parse);
		return res;
	}
}

/** A message */
export class TokenInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public label?: string;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public model?: string;
	/** A field */
	public serialNumber?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public maxSessionCount?: number;
	/** A field */
	public sessionCount?: number;
	/** A field */
	public maxRwSessionCount?: number;
	/** A field */
	public rwSessionCount?: number;
	/** A field */
	public maxPinLen?: number;
	/** A field */
	public minPinLen?: number;
	/** A field */
	public totalPublicMemory?: number;
	/** A field */
	public freePublicMemory?: number;
	/** A field */
	public totalPrivateMemory?: number;
	/** A field */
	public freePrivateMemory?: number;
	/** A field */
	public hardwareVersion?: Version;
	/** A field */
	public firmwareVersion?: Version;
	/** A field */
	public utctime?: string;
	public ToProtoJSON(): Object {
		return {
			label: tsjson.ToProtoJSON.String(this.label),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			model: tsjson.ToProtoJSON.String(this.model),
			serialNumber: tsjson.ToProtoJSON.String(this.serialNumber),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			maxSessionCount: tsjson.ToProtoJSON.StringNumber(this.maxSessionCount),
			sessionCount: tsjson.ToProtoJSON.StringNumber(this.sessionCount),
			maxRwSessionCount: tsjson.ToProtoJSON.StringNumber(this.maxRwSessionCount),
			rwSessionCount: tsjson.ToProtoJSON.StringNumber(this.rwSessionCount),
			maxPinLen: tsjson.ToProtoJSON.StringNumber(this.maxPinLen),
			minPinLen: tsjson.ToProtoJSON.StringNumber(this.minPinLen),
			totalPublicMemory: tsjson.ToProtoJSON.StringNumber(this.totalPublicMemory),
			freePublicMemory: tsjson.ToProtoJSON.StringNumber(this.freePublicMemory),
			totalPrivateMemory: tsjson.ToProtoJSON.StringNumber(this.totalPrivateMemory),
			freePrivateMemory: tsjson.ToProtoJSON.StringNumber(this.freePrivateMemory),
			hardwareVersion: this.hardwareVersion?.ToProtoJSON(),
			firmwareVersion: this.firmwareVersion?.ToProtoJSON(),
			utctime: tsjson.ToProtoJSON.String(this.utctime),
		};
	}
	public static async Parse(data: any): Promise<TokenInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new TokenInfo();
		res.label = await tsjson.Parse.String(objData, "label", "label");
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.model = await tsjson.Parse.String(objData, "model", "model");
		res.serialNumber = await tsjson.Parse.String(objData, "serialNumber", "serial_number");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.maxSessionCount = await tsjson.Parse.Number(objData, "maxSessionCount", "max_session_count");
		res.sessionCount = await tsjson.Parse.Number(objData, "sessionCount", "session_count");
		res.maxRwSessionCount = await tsjson.Parse.Number(objData, "maxRwSessionCount", "max_rw_session_count");
		res.rwSessionCount = await tsjson.Parse.Number(objData, "rwSessionCount", "rw_session_count");
		res.maxPinLen = await tsjson.Parse.Number(objData, "maxPinLen", "max_pin_len");
		res.minPinLen = await tsjson.Parse.Number(objData, "minPinLen", "min_pin_len");
		res.totalPublicMemory = await tsjson.Parse.Number(objData, "totalPublicMemory", "total_public_memory");
		res.freePublicMemory = await tsjson.Parse.Number(objData, "freePublicMemory", "free_public_memory");
		res.totalPrivateMemory = await tsjson.Parse.Number(objData, "totalPrivateMemory", "total_private_memory");
		res.freePrivateMemory = await tsjson.Parse.Number(objData, "freePrivateMemory", "free_private_memory");
		res.hardwareVersion = await tsjson.Parse.Message(objData, "hardwareVersion", "hardware_version", Version.Parse);
		res.firmwareVersion = await tsjson.Parse.Message(objData, "firmwareVersion", "firmware_version", Version.Parse);
		res.utctime = await tsjson.Parse.String(objData, "utctime", "utctime");
		return res;
	}
}

/** A message */
export class Version extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public Major?: number;
	/** A field */
	public Minor?: number;
	public ToProtoJSON(): Object {
		return {
			Major: tsjson.ToProtoJSON.Number(this.Major),
			Minor: tsjson.ToProtoJSON.Number(this.Minor),
		};
	}
	public static async Parse(data: any): Promise<Version> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Version();
		res.Major = await tsjson.Parse.Number(objData, "Major", "Major");
		res.Minor = await tsjson.Parse.Number(objData, "Minor", "Minor");
		return res;
	}
}

/** A message */
export class Mechanism extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public type?: padlock__MechanismType;
	/** A field */
	public minKeySize?: number;
	/** A field */
	public maxKeySize?: number;
	/** A field */
	public flags?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			type: tsjson.ToProtoJSON.Enum(padlock__MechanismType, this.type),
			minKeySize: tsjson.ToProtoJSON.StringNumber(this.minKeySize),
			maxKeySize: tsjson.ToProtoJSON.StringNumber(this.maxKeySize),
			flags: tsjson.ToProtoJSON.Bytes(this.flags),
		};
	}
	public static async Parse(data: any): Promise<Mechanism> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Mechanism();
		res.type = await tsjson.Parse.Enum(objData, "type", "type", padlock__MechanismType);
		res.minKeySize = await tsjson.Parse.Number(objData, "minKeySize", "min_key_size");
		res.maxKeySize = await tsjson.Parse.Number(objData, "maxKeySize", "max_key_size");
		res.flags = await tsjson.Parse.Bytes(objData, "flags", "flags");
		return res;
	}
}

/** A message */
export class Attribute extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public type?: padlock__AttributeType;
	/** A field */
	public value?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			type: tsjson.ToProtoJSON.Enum(padlock__AttributeType, this.type),
			value: tsjson.ToProtoJSON.Bytes(this.value),
		};
	}
	public static async Parse(data: any): Promise<Attribute> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Attribute();
		res.type = await tsjson.Parse.Enum(objData, "type", "type", padlock__AttributeType);
		res.value = await tsjson.Parse.Bytes(objData, "value", "value");
		return res;
	}
}

/** A message */
export class P11Object extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public label?: string;
	/** A field */
	public uuid?: string;
	public ToProtoJSON(): Object {
		return {
			label: tsjson.ToProtoJSON.String(this.label),
			uuid: tsjson.ToProtoJSON.String(this.uuid),
		};
	}
	public static async Parse(data: any): Promise<P11Object> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new P11Object();
		res.label = await tsjson.Parse.String(objData, "label", "label");
		res.uuid = await tsjson.Parse.String(objData, "uuid", "uuid");
		return res;
	}
}

