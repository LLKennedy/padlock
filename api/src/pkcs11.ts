/**
 * Code generated by protoc-gen-tsjson. DO NOT EDIT.
 * versions:
 * 	protoc-gen-tsjson v0.5.2
 * 	protoc            v3.10.1
 * source: pkcs11.proto
 */

import * as tsjson from "@llkennedy/protoc-gen-tsjson";
import { AttributeType as padlock__AttributeType } from "./attributes";
import { MechanismType as padlock__MechanismType } from "./mechanisms";

/** A message */
export class ModuleInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public cryptokiVersion?: Version;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public libraryDescription?: string;
	/** A field */
	public libraryVersion?: Version;
	public ToProtoJSON(): Object {
		return {
			cryptokiVersion: this.cryptokiVersion?.ToProtoJSON(),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			libraryDescription: tsjson.ToProtoJSON.String(this.libraryDescription),
			libraryVersion: this.libraryVersion?.ToProtoJSON(),
		};
	}
	public static async Parse(data: any): Promise<ModuleInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new ModuleInfo();
		res.cryptokiVersion = await tsjson.Parse.Message(objData, "cryptokiVersion", "cryptoki_version", Version.Parse);
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.libraryDescription = await tsjson.Parse.String(objData, "libraryDescription", "library_description");
		res.libraryVersion = await tsjson.Parse.Message(objData, "libraryVersion", "library_version", Version.Parse);
		return res;
	}
}

/** A message */
export class SlotInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public id?: number;
	/** A field */
	public slotDescription?: string;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public hardwareVersion?: Version;
	/** A field */
	public firmwareVersion?: Version;
	/** A field */
	public tokenInfo?: TokenInfo;
	public ToProtoJSON(): Object {
		return {
			id: tsjson.ToProtoJSON.StringNumber(this.id),
			slotDescription: tsjson.ToProtoJSON.String(this.slotDescription),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			hardwareVersion: this.hardwareVersion?.ToProtoJSON(),
			firmwareVersion: this.firmwareVersion?.ToProtoJSON(),
			tokenInfo: this.tokenInfo?.ToProtoJSON(),
		};
	}
	public static async Parse(data: any): Promise<SlotInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new SlotInfo();
		res.id = await tsjson.Parse.Number(objData, "id", "id");
		res.slotDescription = await tsjson.Parse.String(objData, "slotDescription", "slot_description");
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.hardwareVersion = await tsjson.Parse.Message(objData, "hardwareVersion", "hardware_version", Version.Parse);
		res.firmwareVersion = await tsjson.Parse.Message(objData, "firmwareVersion", "firmware_version", Version.Parse);
		res.tokenInfo = await tsjson.Parse.Message(objData, "tokenInfo", "token_info", TokenInfo.Parse);
		return res;
	}
}

/** A message */
export class TokenInfo extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public label?: string;
	/** A field */
	public manufacturerId?: string;
	/** A field */
	public model?: string;
	/** A field */
	public serialNumber?: string;
	/** A field */
	public flags?: number;
	/** A field */
	public maxSessionCount?: number;
	/** A field */
	public sessionCount?: number;
	/** A field */
	public maxRwSessionCount?: number;
	/** A field */
	public rwSessionCount?: number;
	/** A field */
	public maxPinLen?: number;
	/** A field */
	public minPinLen?: number;
	/** A field */
	public totalPublicMemory?: number;
	/** A field */
	public freePublicMemory?: number;
	/** A field */
	public totalPrivateMemory?: number;
	/** A field */
	public freePrivateMemory?: number;
	/** A field */
	public hardwareVersion?: Version;
	/** A field */
	public firmwareVersion?: Version;
	/** A field */
	public utctime?: string;
	public ToProtoJSON(): Object {
		return {
			label: tsjson.ToProtoJSON.String(this.label),
			manufacturerId: tsjson.ToProtoJSON.String(this.manufacturerId),
			model: tsjson.ToProtoJSON.String(this.model),
			serialNumber: tsjson.ToProtoJSON.String(this.serialNumber),
			flags: tsjson.ToProtoJSON.StringNumber(this.flags),
			maxSessionCount: tsjson.ToProtoJSON.StringNumber(this.maxSessionCount),
			sessionCount: tsjson.ToProtoJSON.StringNumber(this.sessionCount),
			maxRwSessionCount: tsjson.ToProtoJSON.StringNumber(this.maxRwSessionCount),
			rwSessionCount: tsjson.ToProtoJSON.StringNumber(this.rwSessionCount),
			maxPinLen: tsjson.ToProtoJSON.StringNumber(this.maxPinLen),
			minPinLen: tsjson.ToProtoJSON.StringNumber(this.minPinLen),
			totalPublicMemory: tsjson.ToProtoJSON.StringNumber(this.totalPublicMemory),
			freePublicMemory: tsjson.ToProtoJSON.StringNumber(this.freePublicMemory),
			totalPrivateMemory: tsjson.ToProtoJSON.StringNumber(this.totalPrivateMemory),
			freePrivateMemory: tsjson.ToProtoJSON.StringNumber(this.freePrivateMemory),
			hardwareVersion: this.hardwareVersion?.ToProtoJSON(),
			firmwareVersion: this.firmwareVersion?.ToProtoJSON(),
			utctime: tsjson.ToProtoJSON.String(this.utctime),
		};
	}
	public static async Parse(data: any): Promise<TokenInfo> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new TokenInfo();
		res.label = await tsjson.Parse.String(objData, "label", "label");
		res.manufacturerId = await tsjson.Parse.String(objData, "manufacturerId", "manufacturer_id");
		res.model = await tsjson.Parse.String(objData, "model", "model");
		res.serialNumber = await tsjson.Parse.String(objData, "serialNumber", "serial_number");
		res.flags = await tsjson.Parse.Number(objData, "flags", "flags");
		res.maxSessionCount = await tsjson.Parse.Number(objData, "maxSessionCount", "max_session_count");
		res.sessionCount = await tsjson.Parse.Number(objData, "sessionCount", "session_count");
		res.maxRwSessionCount = await tsjson.Parse.Number(objData, "maxRwSessionCount", "max_rw_session_count");
		res.rwSessionCount = await tsjson.Parse.Number(objData, "rwSessionCount", "rw_session_count");
		res.maxPinLen = await tsjson.Parse.Number(objData, "maxPinLen", "max_pin_len");
		res.minPinLen = await tsjson.Parse.Number(objData, "minPinLen", "min_pin_len");
		res.totalPublicMemory = await tsjson.Parse.Number(objData, "totalPublicMemory", "total_public_memory");
		res.freePublicMemory = await tsjson.Parse.Number(objData, "freePublicMemory", "free_public_memory");
		res.totalPrivateMemory = await tsjson.Parse.Number(objData, "totalPrivateMemory", "total_private_memory");
		res.freePrivateMemory = await tsjson.Parse.Number(objData, "freePrivateMemory", "free_private_memory");
		res.hardwareVersion = await tsjson.Parse.Message(objData, "hardwareVersion", "hardware_version", Version.Parse);
		res.firmwareVersion = await tsjson.Parse.Message(objData, "firmwareVersion", "firmware_version", Version.Parse);
		res.utctime = await tsjson.Parse.String(objData, "utctime", "utctime");
		return res;
	}
}

/** A message */
export class Version extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public major?: number;
	/** A field */
	public minor?: number;
	public ToProtoJSON(): Object {
		return {
			major: tsjson.ToProtoJSON.Number(this.major),
			minor: tsjson.ToProtoJSON.Number(this.minor),
		};
	}
	public static async Parse(data: any): Promise<Version> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Version();
		res.major = await tsjson.Parse.Number(objData, "major", "major");
		res.minor = await tsjson.Parse.Number(objData, "minor", "minor");
		return res;
	}
}

/** A message */
export class SupportedMechanism extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public type?: padlock__MechanismType;
	/** A field */
	public minKeySize?: number;
	/** A field */
	public maxKeySize?: number;
	/** A field */
	public flags?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			type: tsjson.ToProtoJSON.Enum(padlock__MechanismType, this.type),
			minKeySize: tsjson.ToProtoJSON.StringNumber(this.minKeySize),
			maxKeySize: tsjson.ToProtoJSON.StringNumber(this.maxKeySize),
			flags: tsjson.ToProtoJSON.Bytes(this.flags),
		};
	}
	public static async Parse(data: any): Promise<SupportedMechanism> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new SupportedMechanism();
		res.type = await tsjson.Parse.Enum(objData, "type", "type", padlock__MechanismType);
		res.minKeySize = await tsjson.Parse.Number(objData, "minKeySize", "min_key_size");
		res.maxKeySize = await tsjson.Parse.Number(objData, "maxKeySize", "max_key_size");
		res.flags = await tsjson.Parse.Bytes(objData, "flags", "flags");
		return res;
	}
}

/** A message */
export class Mechanism extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public type?: padlock__MechanismType;
	/** A field */
	public raw?: Uint8Array;
	/** A field */
	public ecdh1?: MechanismECDH1DeriveParams;
	/** A field */
	public gcm?: MechanismGCMParams;
	/** A field */
	public oaep?: MechanismOAEPParams;
	/** A field */
	public pss?: MechanismPSSParams;
	public ToProtoJSON(): Object {
		return {
			type: tsjson.ToProtoJSON.Enum(padlock__MechanismType, this.type),
			raw: tsjson.ToProtoJSON.Bytes(this.raw),
			ecdh1: this.ecdh1?.ToProtoJSON(),
			gcm: this.gcm?.ToProtoJSON(),
			oaep: this.oaep?.ToProtoJSON(),
			pss: this.pss?.ToProtoJSON(),
		};
	}
	public static async Parse(data: any): Promise<Mechanism> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Mechanism();
		res.type = await tsjson.Parse.Enum(objData, "type", "type", padlock__MechanismType);
		res.raw = await tsjson.Parse.Bytes(objData, "raw", "raw");
		res.ecdh1 = await tsjson.Parse.Message(objData, "ecdh1", "ecdh1", MechanismECDH1DeriveParams.Parse);
		res.gcm = await tsjson.Parse.Message(objData, "gcm", "gcm", MechanismGCMParams.Parse);
		res.oaep = await tsjson.Parse.Message(objData, "oaep", "oaep", MechanismOAEPParams.Parse);
		res.pss = await tsjson.Parse.Message(objData, "pss", "pss", MechanismPSSParams.Parse);
		return res;
	}
}

/** A message */
export class MechanismECDH1DeriveParams extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public kdf?: number;
	/** A field */
	public sharedData?: Uint8Array;
	/** A field */
	public publicKeyData?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			kdf: tsjson.ToProtoJSON.Number(this.kdf),
			sharedData: tsjson.ToProtoJSON.Bytes(this.sharedData),
			publicKeyData: tsjson.ToProtoJSON.Bytes(this.publicKeyData),
		};
	}
	public static async Parse(data: any): Promise<MechanismECDH1DeriveParams> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new MechanismECDH1DeriveParams();
		res.kdf = await tsjson.Parse.Number(objData, "kdf", "kdf");
		res.sharedData = await tsjson.Parse.Bytes(objData, "sharedData", "shared_data");
		res.publicKeyData = await tsjson.Parse.Bytes(objData, "publicKeyData", "public_key_data");
		return res;
	}
}

/** A message */
export class MechanismGCMParams extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public iv?: Uint8Array;
	/** A field */
	public aad?: Uint8Array;
	/** A field */
	public tagSize?: number;
	public ToProtoJSON(): Object {
		return {
			iv: tsjson.ToProtoJSON.Bytes(this.iv),
			aad: tsjson.ToProtoJSON.Bytes(this.aad),
			tagSize: tsjson.ToProtoJSON.Number(this.tagSize),
		};
	}
	public static async Parse(data: any): Promise<MechanismGCMParams> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new MechanismGCMParams();
		res.iv = await tsjson.Parse.Bytes(objData, "iv", "iv");
		res.aad = await tsjson.Parse.Bytes(objData, "aad", "aad");
		res.tagSize = await tsjson.Parse.Number(objData, "tagSize", "tag_size");
		return res;
	}
}

/** A message */
export class MechanismOAEPParams extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public hashAlg?: number;
	/** A field */
	public mgf?: number;
	/** A field */
	public sourceType?: number;
	/** A field */
	public sourceData?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			hashAlg: tsjson.ToProtoJSON.Number(this.hashAlg),
			mgf: tsjson.ToProtoJSON.Number(this.mgf),
			sourceType: tsjson.ToProtoJSON.Number(this.sourceType),
			sourceData: tsjson.ToProtoJSON.Bytes(this.sourceData),
		};
	}
	public static async Parse(data: any): Promise<MechanismOAEPParams> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new MechanismOAEPParams();
		res.hashAlg = await tsjson.Parse.Number(objData, "hashAlg", "hash_alg");
		res.mgf = await tsjson.Parse.Number(objData, "mgf", "mgf");
		res.sourceType = await tsjson.Parse.Number(objData, "sourceType", "source_type");
		res.sourceData = await tsjson.Parse.Bytes(objData, "sourceData", "source_data");
		return res;
	}
}

/** A message */
export class MechanismPSSParams extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public hashAlg?: number;
	/** A field */
	public mgf?: number;
	/** A field */
	public saltLength?: number;
	public ToProtoJSON(): Object {
		return {
			hashAlg: tsjson.ToProtoJSON.Number(this.hashAlg),
			mgf: tsjson.ToProtoJSON.Number(this.mgf),
			saltLength: tsjson.ToProtoJSON.Number(this.saltLength),
		};
	}
	public static async Parse(data: any): Promise<MechanismPSSParams> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new MechanismPSSParams();
		res.hashAlg = await tsjson.Parse.Number(objData, "hashAlg", "hash_alg");
		res.mgf = await tsjson.Parse.Number(objData, "mgf", "mgf");
		res.saltLength = await tsjson.Parse.Number(objData, "saltLength", "salt_length");
		return res;
	}
}

/** A message */
export class Attribute extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public type?: padlock__AttributeType;
	/** A field */
	public value?: Uint8Array;
	public ToProtoJSON(): Object {
		return {
			type: tsjson.ToProtoJSON.Enum(padlock__AttributeType, this.type),
			value: tsjson.ToProtoJSON.Bytes(this.value),
		};
	}
	public static async Parse(data: any): Promise<Attribute> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new Attribute();
		res.type = await tsjson.Parse.Enum(objData, "type", "type", padlock__AttributeType);
		res.value = await tsjson.Parse.Bytes(objData, "value", "value");
		return res;
	}
}

/** A message */
export class P11Object extends Object implements tsjson.ProtoJSONCompatible {
	/** A field */
	public label?: string;
	/** A field */
	public uuid?: string;
	public ToProtoJSON(): Object {
		return {
			label: tsjson.ToProtoJSON.String(this.label),
			uuid: tsjson.ToProtoJSON.String(this.uuid),
		};
	}
	public static async Parse(data: any): Promise<P11Object> {
		let objData: Object = tsjson.AnyToObject(data);
		let res = new P11Object();
		res.label = await tsjson.Parse.String(objData, "label", "label");
		res.uuid = await tsjson.Parse.String(objData, "uuid", "uuid");
		return res;
	}
}

